#include <bits/stdc++.h>
#define NAME "a"
using namespace std;

const int NTEST = 100;

mt19937_64 rd(time(0));

long long Rand(long long l, long long h) {
    return uniform_int_distribution<long long>(l, h)(rd);
}

void GenTest() {
    ofstream cout (NAME".inp");
    long long L = Rand(1, 100), n = Rand(1, 10);

    cout << L << ' ' << n << '\n';

    for (int i=1; i<=n; i++) {
        cout << Rand(0, 50) << ' ' << Rand(1, L) << '\n';
    }
}

int main()
{
    srand(time(NULL));
    for (int iTest = 1; iTest <= NTEST; iTest++)
    {
        GenTest();

        // NEED FREOPEN

        //system(NAME"_trau.exe");
        //system(NAME".exe");

        // NO FREOPEN (Just Del the slash)

        system(NAME".exe <"NAME".inp >"NAME".out");
        system(NAME"_trau.exe <"NAME".inp >"NAME".ans");

        if (system("fc "NAME".out "NAME".ans") != 0)
        {
            cout << "Test " << iTest << ": WRONG!\n";
            return 0;
        }
        cout << "Test " << iTest << ": CORRECT!\n";
    }
}


#include <bits/stdc++.h>
#define int long long
#define ii pair<int,int>
#define iii pair<int,ii>
#define fi first
#define se second
#define pb push_back

using namespace std;
const int N = 1e6 + 9;
const int inf = 1e18;
const int mod = 1e9 + 7;
int add(int a, int b) {return (a + b) % mod;}
int mul(int a, int b) {return (a * b) % mod;}
int sub(int a, int b) {return ((a - b) % mod + mod) % mod;}


void logic() {

}

main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    freopen(task ".inp", "r", stdin);
    freopen(task ".out", "w", stdout);

    logic();

    return 0;
}


#include <bits/stdc++.h>
using namespace std;

bool isPrime(long long n) {
    if (n < 2) return false;
    if (n == 2 || n == 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}

void solve() {
    long long m, n;
    cin >> m >> n;
    bool found = false;

    // 1. Chữ số lẻ (1, 3, 5, 7, 9)
    for (long long i = 1; i <= 9; i += 2) {
        if (i >= m && i <= n && isPrime(i)) {
            cout << i << "\n";
            found = true;
        }
    }

    // 2. Các số đối xứng có 2 chữ số (11, 33, 55, 77, 99)
    for (long long i = 1; i <= 9; i += 2) {
        long long num = i * 10 + i;
        if (num >= m && num <= n && isPrime(num)) {
            cout << num << "\n";
            found = true;
        }
    }

    // 3. Tạo số đối xứng có >= 3 chữ số
    // Sinh nửa đầu (left), tạo số nguyên tố đối xứng, kiểm tra range
    for (long long len = 3; len <= 9; len++) {
        long long start = 1;
        for (int k = 1; k < len / 2; k++) start *= 10;
        long long end = start * 10 - 1;

        for (long long left = start; left <= end; left++) {
            string s = to_string(left);
            string rev = s;
            reverse(rev.begin(), rev.end());

            long long num;
            if (len % 2 == 0) {
                num = stoll(s + rev);
            } else {
                num = stoll(s + rev.substr(1));
            }

            if (num > n) continue; // Optimization: if num > n, larger lefts will also be > n
            if (num >= m && isPrime(num)) {
                cout << num << "\n";
                found = true;
            }
        }
    }

    if (!found) cout << 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    solve();
    return 0;
}


--

void sieve() {
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i * i <= N; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= N; j += i)
                isPrime[j] = false;
        }
    }
}

---

void seg_sieve(int l, int r) {
    int i, j;
    for (int i = 2; i * i <= r; ++i) {
        for (int j = max(i * i, (l + i - 1) / i * i); j <= r; j += i) {
            ++f[j - l];
        }
    }
}

void logic() {
    cin >> a >> b;
    seg_sieve(a, b);
    for (int i = max(2LL, a); i <= b; ++i) {
        if (f[i - a] == 0) cout << i << ' ';
    }
}

--

void sieve() {
    for (int i = 2; i <= N; ++i) {
        if (f[i] == 0) {
            for (int j = i; j <= N; j += i) {
                if (f[j] == 0)
                    f[j] = i;
            }
        }
    }
}

void logic() {
    cin >> n >> q;
    for (int i = 2; i <= n; ++i) {
        ++cnt[f[i]];
        // cout << f[i] << ' ';
    }
    while (q--) {
        int x; cin >> x;
        if (x > n) cout << 0 << '\n';
        else cout << cnt[x] << '\n';
    }

    // execute;
}

---

void sieve() {
    for (int i = 1; i <= N; i++) spf[i] = i;
    spf[0] = spf[1] = 0;

    for (int i = 2; i * i <= N; i++) {
        if (spf[i] == i) { 
            for (int j = i * i; j <= N; j += i) {
                if (spf[j] == j)
                    spf[j] = i;
            }
        }
    }
}

void factor(int x) {
    while (x > 1) {
        cout << spf[x] << " ";
        x /= spf[x];
    }
}


---

void tsnt(int n) {
    memset(t, 0, sizeof(t));
    while (n % 2 == 0) {
        ++t[2];
        n /= 2;
    }
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            ++t[i];
            n /= i;
        }
    }
    if (n > 1) t[n]++;
}

void logic() {
    cin >> n;
    tsnt(n);

    for (int i = 2; i <= n; ++i) {
        if (t[i] > 0) cout << i << "^" << t[i] << " ";
    }
    cout << '\n';
}


---

int n, k;
int dp[N];

struct Matrix {
    int a[3][3];
};

Matrix multiply(Matrix A, Matrix B) {
    Matrix C{};
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            for (int t = 0; t < 3; ++t)
                C.a[i][j] = (C.a[i][j] + A.a[i][t] * B.a[t][j]) % k;
    return C;
}

Matrix power(Matrix A, int exp) {
    Matrix res{};
    for (int i = 0; i < 3; ++i) res.a[i][i] = 1;
    while (exp) {
        if (exp & 1) res = multiply(res, A);
        A = multiply(A, A);
        exp >>= 1;
    }
    return res;
}

void sub2() {
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 4;
    for (int i = 4; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
        dp[i] %= k;
    }
    cout << dp[n];
}

void sub3() {
    Matrix M{};
    M.a[0][0] = 1; M.a[0][1] = 1; M.a[0][2] = 1;
    M.a[1][0] = 1; M.a[1][1] = 0; M.a[1][2] = 0;
    M.a[2][0] = 0; M.a[2][1] = 1; M.a[2][2] = 0;

    Matrix P = power(M, n - 3);

    int f3 = 4 % k, f2 = 2 % k, f1 = 1 % k;
    int ans = (P.a[0][0] * f3 + P.a[0][1] * f2 + P.a[0][2] * f1) % k;
    cout << ans;
}


void logic() {
    cin >> n >> k;
    if (n <= 1000000) sub2();
    else sub3();

    // execute;
}


---

int n;
ii a[N], b[N];
vector<ii> pos;

void logic() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].fi;
        a[i].se = i;
    }
    for (int i = 1; i <= n; ++i) {
        cin >> b[i].fi;
        b[i].se = i;
    }
    sort (a + 1, a + n + 1);
    sort (b + 1, b + n + 1);
    int l1 =  1, l2 = 1, r1 = n, r2 = n;
     while (l1 <= r1) {
        if (a[r1].fi > b[r2].fi) {
            pos.pb({a[r1].se, b[r2].se});
            r1--; r2--;
        } else if (a[l1].fi > b[l2].fi) {
            pos.pb({a[l1].se, b[l2].se});
            l1++; l2++;
        } else {
            pos.pb({a[l1].se, b[r2].se});
            l1++; r2--;
        }
    }
    for (auto it : pos) {
        cout << it.fi << " " << it.se << '\n';
    }
    // execute;
}


---

int n;
int a[N];
int mx = -inf, mx2 = -inf;
int mn = inf, mn2 = inf;
bool pos[N];
bool umx = false, umn = false;

void logic() {
    ms(pos, true);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        mx = max(mx, a[i]);
        mn = min(mn, a[i]);
    }
    for (int i = 1; i <= n; ++i) {
        if (!umx and a[i] == mx) {
            pos[i] = false;
            umx = true;
        }
        else if (!umn and a[i] == mn) {
            pos[i] = false;
            umn = true;
        }
    }
    for (int i = 1; i <= n; ++i) {
        if (pos[i]) {
            mx2 = max(mx2, a[i]);
            mn2 = min(mn2, a[i]);
        }
    }

    cout << max(abs(mx + mx2), abs(mn + mn2));
    // execute;
}

---

ll n, k;
str s;
ll dp[T][T][3], next1[N], next2[N];

ll dqcn(int i, int cnt, int check)
{
    if (dp[i][cnt][check] != -1)
    {
        return dp[i][cnt][check];
    }
    int res1 = (cnt == 0 && check);
    if (cnt < k && next1[i] < n + 1)
    {
        res1 = (res1 + dqcn(next1[i], cnt + 1, (check || 1 + cnt == k))) % mod;
    }
    if (cnt > 0 && next2[i] < n + 1)
    {
        res1 = (res1 + dqcn(next2[i], cnt - 1, check)) % mod;
    }
    return dp[i][cnt][check] = res1;
}
void solve()
{
    cin >> s >> k;
    n = s.size();
    s = " " + s;
    int x = n + 1, y = n + 1;
    for (int i = n; i >= 1; i--)
    {
        next1[i] = x;
        next2[i] = y;
        if (s[i] == '(')
        {
            x = i;
        }
        else
        {
            y = i;
        }
    }
    next1[0] = x;
    next2[0] = y;
    memset(dp, -1, sizeof(dp));
    cout << dqcn(0, 0, 0);
}

int main()
{
    F;
    file("BTNK");
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }
    // cerr << "Time: " << (1.0 * clock() / CLOCKS_PER_SEC) << " s.\n";
    return 0;
}

---

void logic() {
    cin >> m >> n;
    for (int i = 1; i <= m; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
        cin >> b[i];
    }

    sort(a + 1, a + m + 1);
    sort(b + 1, b + n + 1);

    int l = 1, r = n/2 + 1;
    int i = 0;
    while (i<=m && l <= n/2 && r<=n) {
        if(b[l] >= a[i]) {
            i++;
            continue;
        }
        while(r<=n and b[r] <= a[i]) r++;
        if (r <= n) ans++;
        l++;
        r++;
        i++;
    }
    cout << ans;
    // execute;
}

---

void logic() {
    cin >> s;
    for (auto x : s) {
        if (x == '#') ++n;
    }
    while (n--) {
        string t; cin >> t;
        sort (t.begin(), t.end());
        v.pb(t);
    }
    reverse(v.begin(), v.end());
    int k; cin >> k;
    k--;
    for (auto x : v) {
        ans.pb(x[k % x.size()]);
        k /= x.size();
    }
    reverse(ans.begin(), ans.end());
    for (auto y : s) {
        if (y == '#') {
            if (!ans.empty()) cout << ans.front();
            ans.pop_front();
        }
        else cout << y;
    }

    // execute;
}


---

int f(int i, int sum) {
    if (i > n) return 0;
    if (sum > k) return -inf;
    if (dp[i][sum] != -1) return dp[i][sum];
    int res = f(i + 1, sum);
    if (sum + a[i] <= k) {
        res = max(res, 1 + f(i + 1, sum + a[i]));
    }
    return dp[i][sum] = res;
}

void logic() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    ms(dp, -1);
    cout << f(1, 0) << '\n';
    dp1[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = f(1, 0); j >= 1; j--) {
            for (int s = k; s >= a[i]; s--) {
                dp1[j][s] = dp1[j][s] + dp1[j - 1][s - a[i]];
            }
        }
    }
    for (int i = 0; i <= k; ++i) {
        cnt += dp1[f(1, 0)][i];
    }
    cout << cnt;

    // execute;
}

---

struct tpa {
    int d, w;
    bool operator < (const tpa& other) const {
        return d < other.d;
    }
};

int n, m;
tpa a[N];
int sw[N], swd[N], d[N];

void logic() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i].d;
    for (int i = 1; i <= n; i++) cin >> a[i].w;

    sort(a + 1, a + n + 1);

    for (int i = 1; i <= n; i++) {
        d[i] = a[i].d;
        sw[i]  = sw[i - 1]  + a[i].w;
        swd[i] = swd[i - 1] + a[i].w * a[i].d;
    }

    while (m--) {
        int p;
        cin >> p;

        int id = upper_bound(d + 1, d + n + 1, p) - d - 1;
        int l = p * sw[id] - swd[id];
        int r = (swd[n] - swd[id]) - p * (sw[n] - sw[id]);

        cout << l + r << '\n';
    }
}


---


void logic() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    int l = 1;
    for (int r = 1; r <= n; ++r) {
        while (!mn.empty() and mn.back() > a[r]) mn.pop_back();
        while (!mx.empty() and mx.back() < a[r]) mx.pop_back();
        mx.pb(a[r]);
        mn.pb(a[r]);
        while (mx.front() - mn.front() > k) {
            if (a[l] == mx.front()) mx.pop_front();
            if (a[l] == mn.front()) mn.pop_front();
            ++l;
        }
        ans += (r - l + 1);
    }
    cout << ans;
    // execute;
}


--- 

void logic() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
        dp[i] = lower_bound(f + 1, f + dis + 1, a[i]) - f;
        f[dp[i]] = a[i];
        if (dp[i] > dis) ++dis;
    }
    cout << dis << '\n';
    int minn = inf;
    for (int i = n; i >= 1; i--) {
        if (dp[i] == dis and a[i] < minn) {
            pos.pb(i);
            minn = a[i];
            --dis;
        }
    }
    reverse(pos.begin(), pos.end());
    for (auto x : pos) {
        cout << x << ' ';
    }

    // execute;
}


---

int n;
vector<int> a(n);
vector<int> len(n, 1), cnt(n, 1);

for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (a[j] < a[i]) {
            if (len[j] + 1 > len[i]) {
                len[i] = len[j] + 1;
                cnt[i] = cnt[j];
            }
            else if (len[j] + 1 == len[i]) {
                cnt[i] += cnt[j];
            }
        }
    }
}

int L = *max_element(len.begin(), len.end());
int ans = 0;
for (int i = 0; i < n; i++)
    if (len[i] == L) ans += cnt[i]; -

struct Node {
    int len;
    long long cnt;
};

Node merge(Node a, Node b) {
    if (a.len > b.len) return a;
    if (b.len > a.len) return b;
    return {a.len, a.cnt + b.cnt};
}

int n;
vector<int> a;
vector<Node> bit;
int m;

void update(int i, Node val) {
    for (; i <= m; i += i & -i)
        bit[i] = merge(bit[i], val);
}

Node query(int i) {
    Node res = {0, 0};
    for (; i > 0; i -= i & -i)
        res = merge(res, bit[i]);
    return res;
}

int main() {
    cin >> n;
    a.resize(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    // Coordinate compression
    vector<int> b = a;
    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());

    for (int i = 0; i < n; i++)
        a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1;

    m = b.size();
    bit.assign(m + 1, {0, 0});

    for (int i = 0; i < n; i++) {
        Node best = query(a[i] - 1);
        if (best.len == 0) best.cnt = 1;
        update(a[i], {best.len + 1, best.cnt});
    }

    Node ans = query(m);
    cout << ans.len << " " << ans.cnt;
}


struct Node {
    int len;#include <bits/stdc++.h>
#define NAME "a"
using namespace std;

const int NTEST = 100;

mt19937_64 rd(time(0));

long long Rand(long long l, long long h) {
    return uniform_int_distribution<long long>(l, h)(rd);
}

void GenTest() {
    ofstream cout (NAME".inp");
    long long L = Rand(1, 100), n = Rand(1, 10);

    cout << L << ' ' << n << '\n';

    for (int i=1; i<=n; i++) {
        cout << Rand(0, 50) << ' ' << Rand(1, L) << '\n';
    }
}

int main()
{
    srand(time(NULL));
    for (int iTest = 1; iTest <= NTEST; iTest++)
    {
        GenTest();

        // NEED FREOPEN

        //system(NAME"_trau.exe");
        //system(NAME".exe");

        // NO FREOPEN (Just Del the slash)

        system(NAME".exe <"NAME".inp >"NAME".out");
        system(NAME"_trau.exe <"NAME".inp >"NAME".ans");

        if (system("fc "NAME".out "NAME".ans") != 0)
        {
            cout << "Test " << iTest << ": WRONG!\n";
            return 0;
        }
        cout << "Test " << iTest << ": CORRECT!\n";
    }
}


#include <bits/stdc++.h>
#define int long long
#define ii pair<int,int>
#define iii pair<int,ii>
#define fi first
#define se second
#define pb push_back

using namespace std;
const int N = 1e6 + 9;
const int inf = 1e18;
const int mod = 1e9 + 7;
int add(int a, int b) {return (a + b) % mod;}
int mul(int a, int b) {return (a * b) % mod;}
int sub(int a, int b) {return ((a - b) % mod + mod) % mod;}


void logic() {

}

main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    freopen(task ".inp", "r", stdin);
    freopen(task ".out", "w", stdout);

    logic();

    return 0;
}


#include <bits/stdc++.h>
using namespace std;

bool isPrime(long long n) {
    if (n < 2) return false;
    if (n == 2 || n == 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}

void solve() {
    long long m, n;
    cin >> m >> n;
    bool found = false;

    // 1. Chữ số lẻ (1, 3, 5, 7, 9)
    for (long long i = 1; i <= 9; i += 2) {
        if (i >= m && i <= n && isPrime(i)) {
            cout << i << "\n";
            found = true;
        }
    }

    // 2. Các số đối xứng có 2 chữ số (11, 33, 55, 77, 99)
    for (long long i = 1; i <= 9; i += 2) {
        long long num = i * 10 + i;
        if (num >= m && num <= n && isPrime(num)) {
            cout << num << "\n";
            found = true;
        }
    }

    // 3. Tạo số đối xứng có >= 3 chữ số
    // Sinh nửa đầu (left), tạo số nguyên tố đối xứng, kiểm tra range
    for (long long len = 3; len <= 9; len++) {
        long long start = 1;
        for (int k = 1; k < len / 2; k++) start *= 10;
        long long end = start * 10 - 1;

        for (long long left = start; left <= end; left++) {
            string s = to_string(left);
            string rev = s;
            reverse(rev.begin(), rev.end());

            long long num;
            if (len % 2 == 0) {
                num = stoll(s + rev);
            } else {
                num = stoll(s + rev.substr(1));
            }

            if (num > n) continue; // Optimization: if num > n, larger lefts will also be > n
            if (num >= m && isPrime(num)) {
                cout << num << "\n";
                found = true;
            }
        }
    }

    if (!found) cout << 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    solve();
    return 0;
}


--

void sieve() {
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i * i <= N; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= N; j += i)
                isPrime[j] = false;
        }
    }
}

---

void seg_sieve(int l, int r) {
    int i, j;
    for (int i = 2; i * i <= r; ++i) {
        for (int j = max(i * i, (l + i - 1) / i * i); j <= r; j += i) {
            ++f[j - l];
        }
    }
}

void logic() {
    cin >> a >> b;
    seg_sieve(a, b);
    for (int i = max(2LL, a); i <= b; ++i) {
        if (f[i - a] == 0) cout << i << ' ';
    }
}

--

void sieve() {
    for (int i = 2; i <= N; ++i) {
        if (f[i] == 0) {
            for (int j = i; j <= N; j += i) {
                if (f[j] == 0)
                    f[j] = i;
            }
        }
    }
}

void logic() {
    cin >> n >> q;
    for (int i = 2; i <= n; ++i) {
        ++cnt[f[i]];
        // cout << f[i] << ' ';
    }
    while (q--) {
        int x; cin >> x;
        if (x > n) cout << 0 << '\n';
        else cout << cnt[x] << '\n';
    }

    // execute;
}

---

void sieve() {
    for (int i = 1; i <= N; i++) spf[i] = i;
    spf[0] = spf[1] = 0;

    for (int i = 2; i * i <= N; i++) {
        if (spf[i] == i) { 
            for (int j = i * i; j <= N; j += i) {
                if (spf[j] == j)
                    spf[j] = i;
            }
        }
    }
}

void factor(int x) {
    while (x > 1) {
        cout << spf[x] << " ";
        x /= spf[x];
    }
}


---

void tsnt(int n) {
    memset(t, 0, sizeof(t));
    while (n % 2 == 0) {
        ++t[2];
        n /= 2;
    }
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            ++t[i];
            n /= i;
        }
    }
    if (n > 1) t[n]++;
}

void logic() {
    cin >> n;
    tsnt(n);

    for (int i = 2; i <= n; ++i) {
        if (t[i] > 0) cout << i << "^" << t[i] << " ";
    }
    cout << '\n';
}


---

int n, k;
int dp[N];

struct Matrix {
    int a[3][3];
};

Matrix multiply(Matrix A, Matrix B) {
    Matrix C{};
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            for (int t = 0; t < 3; ++t)
                C.a[i][j] = (C.a[i][j] + A.a[i][t] * B.a[t][j]) % k;
    return C;
}

Matrix power(Matrix A, int exp) {
    Matrix res{};
    for (int i = 0; i < 3; ++i) res.a[i][i] = 1;
    while (exp) {
        if (exp & 1) res = multiply(res, A);
        A = multiply(A, A);
        exp >>= 1;
    }
    return res;
}

void sub2() {
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 4;
    for (int i = 4; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
        dp[i] %= k;
    }
    cout << dp[n];
}

void sub3() {
    Matrix M{};
    M.a[0][0] = 1; M.a[0][1] = 1; M.a[0][2] = 1;
    M.a[1][0] = 1; M.a[1][1] = 0; M.a[1][2] = 0;
    M.a[2][0] = 0; M.a[2][1] = 1; M.a[2][2] = 0;

    Matrix P = power(M, n - 3);

    int f3 = 4 % k, f2 = 2 % k, f1 = 1 % k;
    int ans = (P.a[0][0] * f3 + P.a[0][1] * f2 + P.a[0][2] * f1) % k;
    cout << ans;
}


void logic() {
    cin >> n >> k;
    if (n <= 1000000) sub2();
    else sub3();

    // execute;
}


---

int n;
ii a[N], b[N];
vector<ii> pos;

void logic() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].fi;
        a[i].se = i;
    }
    for (int i = 1; i <= n; ++i) {
        cin >> b[i].fi;
        b[i].se = i;
    }
    sort (a + 1, a + n + 1);
    sort (b + 1, b + n + 1);
    int l1 =  1, l2 = 1, r1 = n, r2 = n;
     while (l1 <= r1) {
        if (a[r1].fi > b[r2].fi) {
            pos.pb({a[r1].se, b[r2].se});
            r1--; r2--;
        } else if (a[l1].fi > b[l2].fi) {
            pos.pb({a[l1].se, b[l2].se});
            l1++; l2++;
        } else {
            pos.pb({a[l1].se, b[r2].se});
            l1++; r2--;
        }
    }
    for (auto it : pos) {
        cout << it.fi << " " << it.se << '\n';
    }
    // execute;
}


---

int n;
int a[N];
int mx = -inf, mx2 = -inf;
int mn = inf, mn2 = inf;
bool pos[N];
bool umx = false, umn = false;

void logic() {
    ms(pos, true);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        mx = max(mx, a[i]);
        mn = min(mn, a[i]);
    }
    for (int i = 1; i <= n; ++i) {
        if (!umx and a[i] == mx) {
            pos[i] = false;
            umx = true;
        }
        else if (!umn and a[i] == mn) {
            pos[i] = false;
            umn = true;
        }
    }
    for (int i = 1; i <= n; ++i) {
        if (pos[i]) {
            mx2 = max(mx2, a[i]);
            mn2 = min(mn2, a[i]);
        }
    }

    cout << max(abs(mx + mx2), abs(mn + mn2));
    // execute;
}

---

ll n, k;
str s;
ll dp[T][T][3], next1[N], next2[N];

ll dqcn(int i, int cnt, int check)
{
    if (dp[i][cnt][check] != -1)
    {
        return dp[i][cnt][check];
    }
    int res1 = (cnt == 0 && check);
    if (cnt < k && next1[i] < n + 1)
    {
        res1 = (res1 + dqcn(next1[i], cnt + 1, (check || 1 + cnt == k))) % mod;
    }
    if (cnt > 0 && next2[i] < n + 1)
    {
        res1 = (res1 + dqcn(next2[i], cnt - 1, check)) % mod;
    }
    return dp[i][cnt][check] = res1;
}
void solve()
{
    cin >> s >> k;
    n = s.size();
    s = " " + s;
    int x = n + 1, y = n + 1;
    for (int i = n; i >= 1; i--)
    {
        next1[i] = x;
        next2[i] = y;
        if (s[i] == '(')
        {
            x = i;
        }
        else
        {
            y = i;
        }
    }
    next1[0] = x;
    next2[0] = y;
    memset(dp, -1, sizeof(dp));
    cout << dqcn(0, 0, 0);
}

int main()
{
    F;
    file("BTNK");
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }
    // cerr << "Time: " << (1.0 * clock() / CLOCKS_PER_SEC) << " s.\n";
    return 0;
}

---

void logic() {
    cin >> m >> n;
    for (int i = 1; i <= m; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
        cin >> b[i];
    }

    sort(a + 1, a + m + 1);
    sort(b + 1, b + n + 1);

    int l = 1, r = n/2 + 1;
    int i = 0;
    while (i<=m && l <= n/2 && r<=n) {
        if(b[l] >= a[i]) {
            i++;
            continue;
        }
        while(r<=n and b[r] <= a[i]) r++;
        if (r <= n) ans++;
        l++;
        r++;
        i++;
    }
    cout << ans;
    // execute;
}

---

void logic() {
    cin >> s;
    for (auto x : s) {
        if (x == '#') ++n;
    }
    while (n--) {
        string t; cin >> t;
        sort (t.begin(), t.end());
        v.pb(t);
    }
    reverse(v.begin(), v.end());
    int k; cin >> k;
    k--;
    for (auto x : v) {
        ans.pb(x[k % x.size()]);
        k /= x.size();
    }
    reverse(ans.begin(), ans.end());
    for (auto y : s) {
        if (y == '#') {
            if (!ans.empty()) cout << ans.front();
            ans.pop_front();
        }
        else cout << y;
    }

    // execute;
}


---

int f(int i, int sum) {
    if (i > n) return 0;
    if (sum > k) return -inf;
    if (dp[i][sum] != -1) return dp[i][sum];
    int res = f(i + 1, sum);
    if (sum + a[i] <= k) {
        res = max(res, 1 + f(i + 1, sum + a[i]));
    }
    return dp[i][sum] = res;
}

void logic() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    ms(dp, -1);
    cout << f(1, 0) << '\n';
    dp1[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = f(1, 0); j >= 1; j--) {
            for (int s = k; s >= a[i]; s--) {
                dp1[j][s] = dp1[j][s] + dp1[j - 1][s - a[i]];
            }
        }
    }
    for (int i = 0; i <= k; ++i) {
        cnt += dp1[f(1, 0)][i];
    }
    cout << cnt;

    // execute;
}

---

struct tpa {
    int d, w;
    bool operator < (const tpa& other) const {
        return d < other.d;
    }
};

int n, m;
tpa a[N];
int sw[N], swd[N], d[N];

void logic() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i].d;
    for (int i = 1; i <= n; i++) cin >> a[i].w;

    sort(a + 1, a + n + 1);

    for (int i = 1; i <= n; i++) {
        d[i] = a[i].d;
        sw[i]  = sw[i - 1]  + a[i].w;
        swd[i] = swd[i - 1] + a[i].w * a[i].d;
    }

    while (m--) {
        int p;
        cin >> p;

        int id = upper_bound(d + 1, d + n + 1, p) - d - 1;
        int l = p * sw[id] - swd[id];
        int r = (swd[n] - swd[id]) - p * (sw[n] - sw[id]);

        cout << l + r << '\n';
    }
}


---


void logic() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    int l = 1;
    for (int r = 1; r <= n; ++r) {
        while (!mn.empty() and mn.back() > a[r]) mn.pop_back();
        while (!mx.empty() and mx.back() < a[r]) mx.pop_back();
        mx.pb(a[r]);
        mn.pb(a[r]);
        while (mx.front() - mn.front() > k) {
            if (a[l] == mx.front()) mx.pop_front();
            if (a[l] == mn.front()) mn.pop_front();
            ++l;
        }
        ans += (r - l + 1);
    }
    cout << ans;
    // execute;
}


--- 

void logic() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
        dp[i] = lower_bound(f + 1, f + dis + 1, a[i]) - f;
        f[dp[i]] = a[i];
        if (dp[i] > dis) ++dis;
    }
    cout << dis << '\n';
    int minn = inf;
    for (int i = n; i >= 1; i--) {
        if (dp[i] == dis and a[i] < minn) {
            pos.pb(i);
            minn = a[i];
            --dis;
        }
    }
    reverse(pos.begin(), pos.end());
    for (auto x : pos) {
        cout << x << ' ';
    }

    // execute;
}


---

int n;
vector<int> a(n);
vector<int> len(n, 1), cnt(n, 1);

for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (a[j] < a[i]) {
            if (len[j] + 1 > len[i]) {
                len[i] = len[j] + 1;
                cnt[i] = cnt[j];
            }
            else if (len[j] + 1 == len[i]) {
                cnt[i] += cnt[j];
            }
        }
    }
}

int L = *max_element(len.begin(), len.end());
int ans = 0;
for (int i = 0; i < n; i++)
    if (len[i] == L) ans += cnt[i]; -

struct Node {
    int len;
    long long cnt;
};

Node merge(Node a, Node b) {
    if (a.len > b.len) return a;
    if (b.len > a.len) return b;
    return {a.len, a.cnt + b.cnt};
}

int n;
vector<int> a;
vector<Node> bit;
int m;

void update(int i, Node val) {
    for (; i <= m; i += i & -i)
        bit[i] = merge(bit[i], val);
}

Node query(int i) {
    Node res = {0, 0};
    for (; i > 0; i -= i & -i)
        res = merge(res, bit[i]);
    return res;
}

int main() {
    cin >> n;
    a.resize(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    // Coordinate compression
    vector<int> b = a;
    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());

    for (int i = 0; i < n; i++)
        a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1;

    m = b.size();
    bit.assign(m + 1, {0, 0});

    for (int i = 0; i < n; i++) {
        Node best = query(a[i] - 1);
        if (best.len == 0) best.cnt = 1;
        update(a[i], {best.len + 1, best.cnt});
    }

    Node ans = query(m);
    cout << ans.len << " " << ans.cnt;
}


struct Node {
    int len;
    long long cnt;
};

Node merge(Node a, Node b) {
    if (a.len > b.len) return a;
    if (b.len > a.len) return b;
    return {a.len, a.cnt + b.cnt};
}

int n;
vector<int> a;

vector<Node> st;
int sz;

void update(int pos, Node val) {
    for (pos += sz; pos > 0; pos >>= 1)
        st[pos] = merge(st[pos], val);
}

Node query(int l, int r) { // [l, r)
    Node res = {0, 0};
    for (l += sz, r += sz; l < r; l >>= 1, r >>= 1) {
        if (l & 1) res = merge(res, st[l++]);
        if (r & 1) res = merge(res, st[--r]);
    }
    return res;
}

int main() {
    cin >> n;
    a.resize(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    // Coordinate compression
    vector<int> b = a;
    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());

    for (int i = 0; i < n; i++)
        a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin();

    sz = 1;
    while (sz < b.size()) sz <<= 1;
    st.assign(2 * sz, {0, 0});

    for (int i = 0; i < n; i++) {
        Node best = query(0, a[i]);
        if (best.len == 0) best.cnt = 1;
        update(a[i], {best.len + 1, best.cnt});
    }

    Node ans = query(0, sz);
    cout << ans.len << " " << ans.cnt;
}

    long long cnt;
};

Node merge(Node a, Node b) {
    if (a.len > b.len) return a;
    if (b.len > a.len) return b;
    return {a.len, a.cnt + b.cnt};
}

int n;
vector<int> a;

vector<Node> st;
int sz;

void update(int pos, Node val) {
    for (pos += sz; pos > 0; pos >>= 1)
        st[pos] = merge(st[pos], val);
}

Node query(int l, int r) { // [l, r)
    Node res = {0, 0};
    for (l += sz, r += sz; l < r; l >>= 1, r >>= 1) {
        if (l & 1) res = merge(res, st[l++]);
        if (r & 1) res = merge(res, st[--r]);
    }
    return res;
}

int main() {
    cin >> n;
    a.resize(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    // Coordinate compression
    vector<int> b = a;
    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());

    for (int i = 0; i < n; i++)
        a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin();

    sz = 1;
    while (sz < b.size()) sz <<= 1;
    st.assign(2 * sz, {0, 0});

    for (int i = 0; i < n; i++) {
        Node best = query(0, a[i]);
        if (best.len == 0) best.cnt = 1;
        update(a[i], {best.len + 1, best.cnt});
    }

    Node ans = query(0, sz);
    cout << ans.len << " " << ans.cnt;
}
